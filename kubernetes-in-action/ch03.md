# Chapter 3. Pods: running containers in Kubernetes

* Creating, running, and stopping pods
* Organizing pods and other resources with labels
* Performing an operation on all pods with a specific label
* Using namespaces to split pods into non-overlapping groups
* Scheduling pods onto specific types of worker nodes

## 3.1. Introducing pods

* A pod is a co-located group of containers and represents the basic building block in Kubernetes.
* Instead of deploying containers individually, you always deploy and operate on a pod of containers.
* when a pod does contain multiple containers, all of them are always run on a single worker node

![03fig01](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/03fig01_alt.jpg)

### 3.1.1. Understanding why we need pods

* Understanding why multiple containers are better than one contain- ner running multiple processes
* Containers are designed to run only a single process per container (unless the process itself spawns child processes). If you run multiple unrelated processes in a single container, it is your responsibility to keep all those processes running, manage their logs, and so on. For example, you’d have to include a mechanism for automatically restarting individual processes if they crash. Also, all those processes would log to the same standard output, so you’d have a hard time figuring out what process logged what.

### 3.1.2. Understanding pods

* Because you’re not supposed to group multiple processes into a single container, it’s obvious you need another higher-level construct that will allow you to bind containers together and manage them as a single unit. => Pod
* You can take advantage of all the features containers provide, while at the same time giving the processes the illusion of running together.
* Kubernetes achieves this by configuring Docker to have all containers of a pod share the same set of Linux namespaces instead of each container having its own set.
* Because most of the container’s filesystem comes from the container image, by default, the filesystem of each container is fully isolated from other containers.
* Containers of different pods can never run into port conflicts, because each pod has a separate port space.
* All the containers in a pod also have the same loopback network interface, so a container can communicate with other containers in the same pod through localhost.
* All pods in a Kubernetes cluster reside in a single flat, shared, network-address space (shown in figure 3.2), which means every pod can access every other pod at the other pod’s IP address.
* ![03fig02](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/03fig02_alt.jpg)
*  It doesn’t matter if two pods are scheduled onto a single or onto different worker nodes; in both cases the containers inside those pods can communicate with each other across the flat NAT-less network, much like computers on a local area network (LAN), regardless of the actual inter-node network topology.

### 3.1.3. Organizing containers across pods properly

## 3.2. Creating pods from YAML or JSON descriptors

### 3.2.1. Examining a YAML descriptor of an existing pod

### 3.2.2. Creating a simple YAML descriptor for a pod

### 3.2.3. Using kubectl create to create the pod

### 3.2.4. Viewing application logs

### 3.2.5. Sending requests to the pod

## 3.3. Organizing pods with labels

### 3.3.1. Introducing labels

### 3.3.2. Specifying labels when creating a pod

### 3.3.3. Modifying labels of existing pods

## 3.4. Listing subsets of pods through label selectors

### 3.4.1. Listing pods using a label selector

### 3.4.2. Using multiple conditions in a label selector

## 3.5. Using labels and selectors to constrain pod scheduling

### 3.5.1. Using labels for categorizing worker nodes

### 3.5.2. Scheduling pods to specific nodes

### 3.5.3. Scheduling to one specific node

## 3.6. Annotating pods

### 3.6.1. Looking up an object’s annotations

### 3.6.2. Adding and modifying annotations

## 3.7. Using namespaces to group resources

### 3.7.1. Understanding the need for namespaces

### 3.7.2. Discovering other namespaces and their pods

### 3.7.3. Creating a namespace

### 3.7.4. Managing objects in other namespaces

### 3.7.5. Understanding the isolation provided by namespaces

## 3.8. Stopping and removing pods

### 3.8.1. Deleting a pod by name

### 3.8.2. Deleting pods using label selectors

### 3.8.3. Deleting pods by deleting the whole namespace

### 3.8.4. Deleting all pods in a namespace, while keeping the namespace

### 3.8.5. Deleting (almost) all resources in a namespace

## 3.9. Summary


In this chapter, you’ve learned

* How to decide whether certain containers should be grouped together in a pod or not.
* Pods can run multiple processes and are similar to physical hosts in the non-container world.
* YAML or JSON descriptors can be written and used to create pods and then examined to see the specification of a pod and its current state.
* Labels and label selectors should be used to organize pods and easily perform operations on multiple pods at once.
* You can use node labels and selectors to schedule pods only to nodes that have certain features.
* Annotations allow attaching larger blobs of data to pods either by people or tools and libraries.
* Namespaces can be used to allow different teams to use the same cluster as though they were using separate Kubernetes clusters.
* How to use the kubectl explain command to quickly look up the information on any Kubernetes resource.
