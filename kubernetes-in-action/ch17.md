# Chapter 17. Best practices for developing apps

この章のテーマ

* それぞれのリソースが一般的なアプリケーションを実行する上でどのように使われるか
* マシン間での移動がほとんど発生しないアプリと、再配置が頻繁に行われる Pod として稼働しているアプリの違い
* マルチコンポーネントアプリケーション (マイクロサービス) が特定の起動順序に依存すべきでないことを理解する
* Pod の初期化やメインコンテナの開始を遅延させるために利用することができる init コンテナの導入
* コンテナのライフサイクルフックについて
* Kubernetes コンポーネントの分散特性と結果整合性モデルについて
* イメージのサイズを小さく保ち、アノテーションや多次元ラベルによってアプリを管理しやすくする
* マルチノードのクラスタにデプロイする前にローカルでアプリを開発する方法

## 17.1. BRINGING EVERYTHING TOGETHER

* 実際の (一般的な) アプリケーションがどのように構成されているのかを示したのが下図。
* ![17fig01_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig01_alt.jpg)

**訳を記載するか口頭にするかは要検討**

## 17.2. UNDERSTANDING THE POD’S LIFECYCLE

* Pod で実行されるアプリは VM 内で実行されるアプリと似たようなものではあるが、大きな違いもある。
* その一つが、Pod は再配置やスケールインによっていつでも停止し得るという点。

### 17.2.1. Applications must expect to be killed and relocated

* VM で実行されているアプリがマシン間を移動することは滅多にない。
* 移動する場合は運用担当がアプリを移動させて、アプリの再設定は手動でのチェックを行うことになる。
* 一方、Kubernetes では、アプリは頻繁かつ自動的に再配置され、手動で再設定や稼働チェックを行うこともない。
* つまり、開発者はアプリが頻繁に再配置されても問題ないようにする必要がある。

Expecting the local IP and hostname to change

* Pod が再配置 (古い Pod が停止して新しい Pod が起動) されると、IP アドレスだけでなく Pod 名やホスト名も変わることになる
* アプリがステートレスであれば通常問題ないが、ステートフルの場合は影響なしに再配置に対応することはできない
* その場合は StatefulSet を使う (新しい Pod が起動しても以前と同じホスト名で同じボリュームがマウントされる) **要確認**
* それでも IP は変わるので、IP は代わり得るという前提でアプリを作成する必要がある。

Expecting the data written to disk to disappear

* Pod がディスクにデータを書き込む場合、書き込み先に永続ストレージをマウントしないと Pod の再配置によってデータが参照できなくなる
* 再配置される場合だけでなく、Pod が生きている間にもデータが消える可能性がある。
* プロセスクラッシュ、liveness probe がエラーを返す、OOM Killer にプロセスが kill されるなどの理由で、個々のコンテナが再起動される可能性があり、これが発生すると Pod の再配置は発生しなくてもコンテナが新たに作成され、書き込み可能レイヤーが新しくなる。
* ![17fig02_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig02_alt.jpg)
* それを防ぎたい場合には少なくとも Pod スコープのボリュームを使う必要がある **要確認**
* Pod が生きていればボリュームを使い続けられるので、コンテナが再起動した場合でも前のデータが残る
* ![17fig03_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig03_alt.jpg)
* ただし、ボリュームのデータの破損に起因してコンテナがクラッシュするようなケースだと、継続的にコンテナがクラッシュし続けることになってしまう。
* コンテナが再起動しても前のファイルを保持し続けるようにするのはデメリットもあるので、使用するかどうかは慎重に検討すべき。

### 17.2.2. Rescheduling of dead or partially dead pods

* ![17fig04_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig04_alt.jpg)

### 17.2.3. Starting pods in a specific order

### 17.2.4. Adding lifecycle hooks

### 17.2.5. Understanding pod shutdown

* ![17fig05_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig05_alt.jpg)

* ![17fig06_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig06_alt.jpg)

## 17.3. ENSURING ALL CLIENT REQUESTS ARE HANDLED PROPERLY

### 17.3.1. Preventing broken client connections when a pod is starting up

### 17.3.2. Preventing broken connections during pod shut-down

* ![17fig07_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig07_alt.jpg)

* ![17fig08_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig08_alt.jpg)

* ![17fig09_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig09_alt.jpg)


## 17.4. MAKING YOUR APPS EASY TO RUN AND MANAGE IN KUBERNETES

### 17.4.1. Making manageable container images

### 17.4.2. Properly tagging your images and using imagePullPolicy wisely

### 17.4.3. Using multi-dimensional instead of single-dimensional labels

### 17.4.4. Describing each resource through annotations

### 17.4.5. Providing information on why the process terminated

### 17.4.6. Handling application logs

* ![17fig10_alt](https://learning.oreilly.com/library/view/kubernetes-in-action/9781617293726/17fig10_alt.jpg)

## 17.5. BEST PRACTICES FOR DEVELOPMENT AND TESTING

### 17.5.1. Running apps outside of Kubernetes during development

### 17.5.2. Using Minikube in development

### 17.5.3. Versioning and auto-deploying resource manifests

### 17.5.4. Introducing Ksonnet as an alternative to writing YAML/JSON manifests

### 17.5.5. Employing Continuous Integration and Continuous Delivery (CI/CD)
